
<!DOCTYPE html>

<html>

<head>
<title>untitled</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">

<style>
html, body {
    overflow: hidden;
    height: 100%;
    margin: 0;
    padding: 0;
    background: black;
}

#game-wrapper {
    max-width: 100vh;
    max-height: 100vw;
    margin: 0 auto;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
}

canvas {
    display: block;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    image-rendering: -moz-crisp-edges;
}

canvas:focus {
    outline: none;
}

</style>

<script>
window.GAME_DATA = {"errorState":"","spritePalette":[0,1,2],"version":1.3,"currentSpriteIndex":2,"spriteList":[{"name":"avatar","isAvatar":true,"isWall":false,"isItem":false,"isTransparent":false,"colorIndex":1,"width":12,"height":12,"frameList":[[0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]],"scriptList":{"on-push":"","on-message":""}},{"name":"wall","isAvatar":false,"isWall":true,"isItem":false,"isTransparent":false,"colorIndex":1,"width":12,"height":12,"frameList":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]],"scriptList":{"on-push":"","on-message":""}},{"name":"sprite-1","isAvatar":false,"isWall":false,"isItem":false,"isTransparent":false,"colorIndex":1,"width":12,"height":12,"frameList":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,1,0,1,0,0,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,1,0,0,1,1,0,1,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0]],"scriptList":{"on-push":"aqu√≠ se oye demasiado","on-message":""}}],"spriteWidth":12,"spriteHeight":12,"currentRoomIndex":0,"roomList":[{"name":"room-0-0","paletteName":"palette-1","musicName":"technocito","tileList":[{"spriteName":"avatar","x":13,"y":13},{"spriteName":"wall","x":4,"y":0},{"spriteName":"wall","x":6,"y":1},{"spriteName":"wall","x":7,"y":1},{"spriteName":"wall","x":8,"y":1},{"spriteName":"wall","x":13,"y":1},{"spriteName":"wall","x":14,"y":1},{"spriteName":"wall","x":15,"y":1},{"spriteName":"wall","x":16,"y":1},{"spriteName":"wall","x":17,"y":1},{"spriteName":"wall","x":19,"y":0},{"spriteName":"wall","x":21,"y":0},{"spriteName":"wall","x":23,"y":0},{"spriteName":"wall","x":0,"y":0},{"spriteName":"wall","x":2,"y":0},{"spriteName":"wall","x":12,"y":1},{"spriteName":"wall","x":11,"y":1},{"spriteName":"wall","x":10,"y":1},{"spriteName":"wall","x":9,"y":1},{"spriteName":"wall","x":8,"y":0},{"spriteName":"wall","x":7,"y":0},{"spriteName":"wall","x":6,"y":0},{"spriteName":"wall","x":9,"y":0},{"spriteName":"wall","x":10,"y":0},{"spriteName":"wall","x":11,"y":0},{"spriteName":"wall","x":12,"y":0},{"spriteName":"wall","x":13,"y":0},{"spriteName":"wall","x":14,"y":0},{"spriteName":"wall","x":15,"y":0},{"spriteName":"wall","x":16,"y":0},{"spriteName":"wall","x":17,"y":0},{"spriteName":"wall","x":6,"y":3},{"spriteName":"wall","x":7,"y":3},{"spriteName":"wall","x":8,"y":3},{"spriteName":"wall","x":9,"y":3},{"spriteName":"wall","x":10,"y":3},{"spriteName":"wall","x":11,"y":3},{"spriteName":"wall","x":12,"y":3},{"spriteName":"wall","x":13,"y":3},{"spriteName":"wall","x":14,"y":3},{"spriteName":"wall","x":15,"y":3},{"spriteName":"wall","x":16,"y":3},{"spriteName":"wall","x":17,"y":3},{"spriteName":"wall","x":17,"y":2},{"spriteName":"wall","x":16,"y":2},{"spriteName":"wall","x":15,"y":2},{"spriteName":"wall","x":14,"y":2},{"spriteName":"wall","x":13,"y":2},{"spriteName":"wall","x":12,"y":2},{"spriteName":"wall","x":11,"y":2},{"spriteName":"wall","x":10,"y":2},{"spriteName":"wall","x":9,"y":2},{"spriteName":"wall","x":8,"y":2},{"spriteName":"wall","x":7,"y":2},{"spriteName":"wall","x":6,"y":2},{"spriteName":"wall","x":23,"y":2},{"spriteName":"wall","x":23,"y":4},{"spriteName":"wall","x":0,"y":2},{"spriteName":"wall","x":0,"y":4},{"spriteName":"wall","x":23,"y":6},{"spriteName":"wall","x":0,"y":6},{"spriteName":"sprite-1","x":20,"y":5},{"spriteName":"sprite-1","x":20,"y":6},{"spriteName":"sprite-1","x":19,"y":6},{"spriteName":"sprite-1","x":19,"y":5},{"spriteName":"sprite-1","x":19,"y":7},{"spriteName":"sprite-1","x":20,"y":7},{"spriteName":"sprite-1","x":3,"y":6},{"spriteName":"sprite-1","x":3,"y":5},{"spriteName":"sprite-1","x":4,"y":6},{"spriteName":"sprite-1","x":4,"y":5},{"spriteName":"sprite-1","x":4,"y":7},{"spriteName":"sprite-1","x":3,"y":7}],"scriptList":{"on-enter":"","on-exit":""}}],"roomWidth":24,"roomHeight":18,"worldWidth":1,"worldHeight":1,"worldName":"a new world","worldWrapHorizontal":false,"worldWrapVertical":false,"worldScriptList":{"on-start":"{position fullscreen}{world-name}{/position}"},"currentPaletteIndex":0,"paletteList":[{"name":"palette-1","colorList":["#121a30","#ffffeb"]}],"currentMusicIndex":0,"musicList":[{"name":"technocito","beat":0.375,"voiceList":[{"instrument":{"wave":"sine","attack":0,"decay":0.5,"sustain":0,"release":0},"noteList":[null,932.33,783.99,698.46,null,null,null,null,null,932.33,783.99,698.46,null,523.25,622.25,null]},{"instrument":{"wave":"triangle","attack":0,"decay":0.5,"sustain":0.1,"release":0.1},"noteList":[null,null,null,null,null,349.23,392,null,null,null,null,null,392,null,null,null]},{"instrument":{"wave":"triangle","attack":0,"decay":0.5,"sustain":0.5,"release":0.3},"noteList":[null,null,155.56,null,null,155.56,155.56,null,null,155.56,155.56,155.56,155.56,null,null,null]},{"instrument":{"wave":"square","attack":0,"decay":0.2,"sustain":0,"release":0,"volume":0.5},"noteList":[65.41,null,77.78,null,77.78,null,77.78,null,65.41,null,77.78,null,77.78,null,77.78,65.41]}]}],"fontResolution":1,"fontDirection":"ltr","fontData":{"name":"ascii_tiny","width":4,"height":5,"characterList":{"32":{"data":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},"33":{"data":[1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0]},"34":{"data":[1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0]},"35":{"data":[1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,0,0,0,0]},"36":{"data":[0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,0,0,0,0,0]},"37":{"data":[1,0,1,0,0,1,1,0,1,1,0,0,1,0,1,0,0,0,0,0]},"38":{"data":[0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0]},"39":{"data":[1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},"40":{"data":[0,0,1,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0]},"41":{"data":[0,1,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0]},"42":{"data":[1,0,1,0,0,1,0,0,1,0,1,0,0,0,0,0,0,0,0,0]},"43":{"data":[0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0]},"44":{"data":[0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0]},"45":{"data":[0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0]},"46":{"data":[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0]},"47":{"data":[0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0]},"48":{"data":[0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,0,0,0,0]},"49":{"data":[0,1,0,0,1,1,0,0,0,1,0,0,1,1,1,0,0,0,0,0]},"50":{"data":[1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,0,0]},"51":{"data":[1,1,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,0,0]},"52":{"data":[1,0,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,0,0]},"53":{"data":[1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0]},"54":{"data":[1,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0]},"55":{"data":[1,1,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,0,0,0]},"56":{"data":[1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,0,0]},"57":{"data":[1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,0,0]},"58":{"data":[1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0]},"59":{"data":[0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0]},"60":{"data":[0,0,1,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0]},"61":{"data":[1,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0]},"62":{"data":[1,0,0,0,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0]},"63":{"data":[1,1,0,0,0,0,1,0,0,1,0,0,0,1,0,0,0,0,0,0]},"64":{"data":[0,1,0,0,1,1,1,0,1,0,1,0,0,1,0,0,0,0,0,0]},"65":{"data":[0,1,0,0,1,0,1,0,1,1,1,0,1,0,1,0,0,0,0,0]},"66":{"data":[1,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,0,0]},"67":{"data":[0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,0,0,0,0]},"68":{"data":[1,1,0,0,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0]},"69":{"data":[1,1,1,0,1,0,0,0,1,1,0,0,1,1,1,0,0,0,0,0]},"70":{"data":[1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,0]},"71":{"data":[1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,0,0,0,0,0]},"72":{"data":[1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,0,0,0,0]},"73":{"data":[1,1,1,0,0,1,0,0,0,1,0,0,1,1,1,0,0,0,0,0]},"74":{"data":[1,1,1,0,0,0,1,0,1,0,1,0,0,1,1,0,0,0,0,0]},"75":{"data":[1,0,1,0,1,1,0,0,1,1,0,0,1,0,1,0,0,0,0,0]},"76":{"data":[1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,0,0,0,0,0]},"77":{"data":[1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0]},"78":{"data":[1,1,0,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,0,0]},"79":{"data":[1,1,1,0,1,0,1,0,1,0,1,0,1,1,1,0,0,0,0,0]},"80":{"data":[1,1,0,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0]},"81":{"data":[1,1,1,0,1,0,1,0,1,1,0,0,0,0,1,0,0,0,0,0]},"82":{"data":[1,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,0,0,0]},"83":{"data":[1,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]},"84":{"data":[1,1,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0]},"85":{"data":[1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,0,0,0,0,0]},"86":{"data":[1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,0,0,0,0]},"87":{"data":[1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,0,0,0,0,0]},"88":{"data":[1,0,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,0]},"89":{"data":[1,0,1,0,1,1,1,0,0,1,0,0,0,1,0,0,0,0,0,0]},"90":{"data":[1,1,1,0,0,1,1,0,1,1,0,0,1,1,1,0,0,0,0,0]},"91":{"data":[0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,0]},"92":{"data":[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0]},"93":{"data":[0,1,1,0,0,0,1,0,0,0,1,0,0,1,1,0,0,0,0,0]},"94":{"data":[0,1,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0]},"95":{"data":[0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0]},"96":{"data":[1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},"97":{"data":[0,1,0,0,1,0,1,0,1,1,1,0,1,0,1,0,0,0,0,0]},"98":{"data":[1,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,0,0]},"99":{"data":[0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,0,0,0,0]},"100":{"data":[1,1,0,0,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0]},"101":{"data":[1,1,1,0,1,0,0,0,1,1,0,0,1,1,1,0,0,0,0,0]},"102":{"data":[1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,0]},"103":{"data":[1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,0,0,0,0,0]},"104":{"data":[1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,0,0,0,0]},"105":{"data":[1,1,1,0,0,1,0,0,0,1,0,0,1,1,1,0,0,0,0,0]},"106":{"data":[1,1,1,0,0,0,1,0,1,0,1,0,0,1,1,0,0,0,0,0]},"107":{"data":[1,0,1,0,1,1,0,0,1,1,0,0,1,0,1,0,0,0,0,0]},"108":{"data":[1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,0,0,0,0,0]},"109":{"data":[1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0]},"110":{"data":[1,1,0,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,0,0]},"111":{"data":[1,1,1,0,1,0,1,0,1,0,1,0,1,1,1,0,0,0,0,0]},"112":{"data":[1,1,0,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0]},"113":{"data":[1,1,1,0,1,0,1,0,1,1,0,0,0,0,1,0,0,0,0,0]},"114":{"data":[1,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,0,0,0]},"115":{"data":[1,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]},"116":{"data":[1,1,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0]},"117":{"data":[1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,0,0,0,0,0]},"118":{"data":[1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,0,0,0,0]},"119":{"data":[1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,0,0,0,0,0]},"120":{"data":[1,0,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,0]},"121":{"data":[1,0,1,0,1,1,1,0,0,1,0,0,0,1,0,0,0,0,0,0]},"122":{"data":[1,1,1,0,0,1,1,0,1,1,0,0,1,1,1,0,0,0,0,0]},"123":{"data":[0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,0,0,0,0,0]},"124":{"data":[0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0]},"125":{"data":[0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,0]},"126":{"data":[0,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}}},"modList":[]}
</script>

<script>
let Text = (() => {

return {

    drawNode: ({ nodes, nodeIndex = 0, canvas, context, fontData, fontDirection, timestamp, bgX = 0, bgY = 0, charsSoFar = 0, maxChars, spacingSoFar = 0, currentLine = 0, linesPerPage = 2 }) => {
        if (nodeIndex >= nodes.length) {
            return nodeIndex
        }

        let node = nodes[nodeIndex]

        if (node.type === 'text') {
            let nodeIsComplete = true

            // set position
            window.textPosition = node.position

            // find starting position
            let x = bgX + (fontData.width * 2)
            let y = (currentLine * fontData.height * 2) + bgY + (fontData.height * 2)

            // find widths of page and a single space
            let pageWidth = canvas.width - (fontData.width * 6)
            let spaceWidth = fontData.width

            // figure out if first word in node should be preceeded by a space
            let startWithSpace = node.text.startsWith(' ')
            let previousTextNodes = nodes.slice(0, nodeIndex).filter(n => n.type === 'text')
            if (previousTextNodes.length > 0) {
                let previousTextNode = previousTextNodes[previousTextNodes.length - 1]
                let previousText = previousTextNode.text
                if (previousText.endsWith(' ')) startWithSpace = true
            }

            // divide text into words
            let words = node.text.split(/\s+/)

            // draw each word on screen
            for (let i = 0; i < words.length; i++) {
                let word = words[i]

                // ignore empty words
                if (!word) continue

                // add preceeding space if not first word in line or node
                if ((i > 0 || startWithSpace) && spacingSoFar > 0) word = ' ' + word

                // find how many characters are left
                let charsLeft = maxChars - charsSoFar
                if (maxChars >= 0 && charsLeft <= 0) {
                    return -1
                }

                // find how much space (pixels) left
                let spaceLeftOnLine = pageWidth - spacingSoFar

                // truncate word if needed
                let wordWidth = Text.textWidth(fontData, word)
                let displayWord = maxChars >= 0 ? word.substring(0, charsLeft) : word
                if (displayWord.length < word.length) {
                    nodeIsComplete = false
                }

                if (wordWidth <= spaceLeftOnLine || spacingSoFar === 0) {

                    // draw word
                    let seqWidth = Text.drawSeq(
                        context,
                        fontData,
                        fontDirection,
                        displayWord,
                        node.color,
                        node.style,
                        x + spacingSoFar,
                        y,
                        timestamp
                    )
                    spacingSoFar += seqWidth
                    charsSoFar += displayWord.length

                } else {

                    // put remaining text in new node
                    let remainingText = words.slice(i).join(' ')
                    if (remainingText.trim().length === 0) break
                    nodes.splice(nodeIndex + 1, 0, {
                        type: 'text',
                        text: remainingText,
                        color: node.color,
                        position: node.position,
                        style: node.style
                    })

                    // start new line
                    nodes.splice(nodeIndex + 1, 0, { type: 'line-break' })

                    // shorten this node
                    node.text = words.slice(0, i).join(' ')

                    break

                }
            }

            if (!nodeIsComplete) {
                return -1
            }
        }

        if (node.type === 'line-break') {
            currentLine += 1
            spacingSoFar = 0
            if (currentLine >= linesPerPage) {
                node.type = 'page-break'
            }
        }

        if (node.type === 'page-break') {
            currentLine = 0
            spacingSoFar = 0
            charsSoFar = 0
            return nodeIndex + 1
        }
        
        if (node.type === 'action') {
            // initialize list of local nodes
            let localNodes = []
            let addNode = (node) => {
                localNodes.push(node)
            }

            // run action
            node.actionFunc(addNode)

            // insert any nodes generated by action into list of nodes
            localNodes.forEach((node, i) => {
                nodes.splice(nodeIndex + 1 + i, 0, node)
            })

            // mark action as completed so it doesn't run again
            if (node.actionName === 'delay') {
                charsSoFar += window.delayTimer
            } else {
                node.type = 'completed-action'
            }
        }

        // draw next node
        return Text.drawNode({
            nodeIndex: nodeIndex + 1,
            nodes,
            canvas, context,
            fontData, fontDirection,
            timestamp,
            bgX, bgY,
            charsSoFar, maxChars,
            spacingSoFar, currentLine, linesPerPage
        })
    },

    drawBackground: (context, fontData, position, linesPerPage = 2) => {
        let bgWidth = context.canvas.width - (fontData.width * 2)
        let bgHeight = Math.floor(fontData.height * (linesPerPage * 2 + 3))
        let bgX = fontData.width
        let bgY
        if (position === 'top') {
            bgY = fontData.width
        } else if (position === 'bottom') {
            bgY = context.canvas.height - bgHeight - fontData.width
        } else {
            bgY = Math.floor(context.canvas.height / 2 - bgHeight / 2)
        }

        if (position === 'none') {
            // don't draw background
        } else if (position === 'fullscreen') {
            context.fillStyle = 'black'
            context.fillRect(0, 0, context.canvas.width, context.canvas.height)
        } else {
            context.fillStyle = 'black'
            context.fillRect(bgX, bgY, bgWidth, bgHeight)
        }

        return { bgX, bgY, bgWidth, bgHeight }
    },

    drawContinueIndicator: (context, fontData, bgX, bgY, bgWidth, bgHeight) => {
        let indicatorWidth = fontData.width
        let indicatorHeight = fontData.width
        let indicatorX = bgX + bgWidth - fontData.width - indicatorWidth
        let indicatorY = bgY + bgHeight - fontData.height - indicatorHeight
        context.fillStyle = 'white'
        context.fillRect(indicatorX, indicatorY, indicatorWidth, indicatorHeight)
    },

    textWidth: (fontData, text) => {
        let { width, characterList } = fontData
        let textWidth = 0
        for (let i = 0; i < text.length; i++) {
            let charCode = text.charCodeAt(i)
            let charData = characterList[charCode]
            if (!charData) continue
            let charWidth = !isNaN(charData.width) ? charData.width : width
            textWidth += charWidth
        }
        return textWidth
    },

    drawSeq: (context, fontData, fontDirection, text, color, style, x, y, timestamp, i = 0) => {
        context.fillStyle = color

        let numChars = text.length
        let spacingSoFar = 0

        for (let j = 0; j < numChars; j++) {
            let charCode = text.charCodeAt(j)
            let xOffset = (fontDirection === 'rtl') ? x - spacingSoFar : x + spacingSoFar
            let newSpacing = Text.drawChar(context, fontData, charCode, xOffset, y, style, timestamp, i + j)
            spacingSoFar += newSpacing
        }

        return spacingSoFar
    },

    drawChar: (context, fontData, charCode, x, y, style, timestamp, i) => {
        let { width, height, characterList } = fontData

        let charData = characterList[charCode]
        if (!charData) return 0

        if (!isNaN(charData.width)) width = charData.width
        if (!isNaN(charData.height)) height = charData.height

        let offsetX = 0
        let offsetY = 0
        if (!isNaN(charData.offsetX)) offsetX = charData.offsetX
        if (!isNaN(charData.offsetY)) offsetY = charData.offsetY

        let spacing = width
        if (!isNaN(charData.spacing)) spacing = charData.spacing

        let styleX = 0
        let styleY = 0
        if (style === 'wavy') {
            styleY = Math.floor(Math.sin(timestamp / (300) + (i / 2)) * (height / 3))
        }
        else if (style === 'shaky') {
            styleX = Math.floor(Math.cos(timestamp / (20) + i) * (width / 10))
            styleY = Math.floor(Math.sin(timestamp / (10) + i) * (height / 10))
        }

        for (let cx = 0; cx < width; cx++) {
            for (let cy = 0; cy < height; cy++) {
                let pixel = charData.data[cy * width + cx]
                if (pixel) {
                    context.fillRect(x + cx + offsetX + styleX, y + cy + offsetY + styleY, 1, 1)
                }
            }
        }

        return spacing
    }

}

})()
</script>

<script>
let MusicPlayer = (() => {

return {
    audioContext: null,

    audioLoop: null,

    init: () => {
        let AudioContext = window.AudioContext || window.webkitAudioContext
        if (AudioContext) {
            MusicPlayer.audioContext = new AudioContext()
        }

        let fixAudioContext = (e) => {
            if (AudioContext) {
                // create empty buffer and play it
                let buffer = MusicPlayer.audioContext.createBuffer(1, 1, 22050)
                let source = MusicPlayer.audioContext.createBufferSource()
                source.buffer = buffer;
                source.connect(MusicPlayer.audioContext.destination)
                source.start(0)

                // unlock html5 audio to play web audio when mute toggle is on
                let silenceDataURL = "data:audio/mp3;base64,//MkxAAHiAICWABElBeKPL/RANb2w+yiT1g/gTok//lP/W/l3h8QO/OCdCqCW2Cw//MkxAQHkAIWUAhEmAQXWUOFW2dxPu//9mr60ElY5sseQ+xxesmHKtZr7bsqqX2L//MkxAgFwAYiQAhEAC2hq22d3///9FTV6tA36JdgBJoOGgc+7qvqej5Zu7/7uI9l//MkxBQHAAYi8AhEAO193vt9KGOq+6qcT7hhfN5FTInmwk8RkqKImTM55pRQHQSq//MkxBsGkgoIAABHhTACIJLf99nVI///yuW1uBqWfEu7CgNPWGpUadBmZ////4sL//MkxCMHMAH9iABEmAsKioqKigsLCwtVTEFNRTMuOTkuNVVVVVVVVVVVVVVVVVVV//MkxCkECAUYCAAAAFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV"
                let tag = document.createElement('audio')
                tag.controls = false
                tag.preload = 'auto'
                tag.loop = false
                tag.src = silenceDataURL
                tag.play()
            }

            document.removeEventListener('touchstart', fixAudioContext)
            document.removeEventListener('touchend', fixAudioContext)
        }

        document.addEventListener('touchstart', fixAudioContext)
        document.addEventListener('touchend', fixAudioContext)

    },

    playNote: (freq, { wave = 'triangle', attack = 0, decay = 0.5, sustain = 0, release = 0, volume = 1 }, beat = 1) => {
        if (!freq) return
        if (!MusicPlayer.audioContext) MusicPlayer.init()

        let t = MusicPlayer.audioContext.currentTime
    
        let osc = MusicPlayer.audioContext.createOscillator()
        osc.type = wave
        osc.frequency.value = freq
    
        let env = MusicPlayer.audioContext.createGain()
        env.connect(MusicPlayer.audioContext.destination)
        env.gain.cancelScheduledValues(t)
        env.gain.setValueAtTime(0, t)

        volume *= 0.1
    
        env.gain.linearRampToValueAtTime(volume, t + (attack * beat))
        env.gain.linearRampToValueAtTime(sustain * volume, t + (attack * beat) + (decay * beat))
        env.gain.linearRampToValueAtTime(sustain * volume, t + beat)
        env.gain.linearRampToValueAtTime(0, t + beat + (release * beat))
    
        osc.connect(env)
        osc.start()
        osc.stop(t + beat + (release * beat))
    },

    playSong: ({ beat, voiceList }, beatFunction) => {
        let noteIndex = 0
        let noteCount = voiceList[0] && voiceList[0].noteList ? voiceList[0].noteList.length : 0
        MusicPlayer.audioLoop = window.setInterval(() => {
            if (window.muteMusic) return
            voiceList.forEach(({ instrument, noteList }) => {
                let freq = noteList[noteIndex]
                if (freq) {
                    MusicPlayer.playNote(freq, instrument, beat)
                }
            })
            if (beatFunction) beatFunction(noteIndex)
            noteIndex++
            if (noteIndex >= noteCount) noteIndex = 0
        }, beat * 1000)
    },

    stopSong: () => {
        window.clearInterval(MusicPlayer.audioLoop)
    }
}

})()
</script>

<script>
let Script = (() => {

return {
    run: (script, game, context) => {
        let parsedScript = Script.parse(script)

        let dialogNodes = []

        // default text settings
        let defaultTextPosition = game.avatarY < game.world.roomHeight / 2 ? 'bottom' : 'top'
        let defaultTextSettings = {
            color: 'white',
            style: 'normal',
            position: defaultTextPosition
        }

        // some helper functions
        let isStr = x => typeof x === 'string'
        let isInt = x => !isNaN(x) && parseInt(x) === parseFloat(x)
        let isArr = x => Array.isArray(x)

        // define expressions
        let expressions = {

            'world-name': (game) => game.world.worldName,

            'room-name': (game) => game.currentRoom.name,

            'avatar-room': (game) => game.currentRoom.name,

            'avatar-x': (game) => game.avatarX,

            'avatar-y': (game) => game.avatarY,

            'avatar-name': (game) => game.avatar.name,

            'sprite-room': (game, context) => {
                if (!context) return
                let room = game.world.roomList[context.roomIndex]
                return room.name
            },

            'sprite-x': (game, context) => {
                if (!context) return
                return context.tile.x
            },

            'sprite-y': (game, context) => {
                if (!context) return
                return context.tile.y
            },

            'sprite-name': (game, context) => {
                if (!context) return
                return context.sprite.name
            },

            'sprite-wall': (game, context) => {
                if (!context) return
                return context.sprite.isWall
            },

            'sprite-item': (game, context) => {
                if (!context) return
                return context.sprite.isItem
            },

            'add': (game, context, args) => {
                if (args.length < 2) return 0
                return args.reduce((prev, curr) => {
                    if (isInt(curr)) return prev + curr
                    else return prev
                }, 0)
            },

            'sub': (game, context, args) => {
                if (args.length < 2) return 0
                if (!isInt(args[0])) return 0
                return args.slice(1).reduce((prev, curr) => {
                    if (isInt(curr)) return prev - curr
                    else return prev
                }, args[0])
            },

            'mul': (game, context, args) => {
                if (args.length < 2) return 0
                return args.reduce((prev, curr) => {
                    if (isInt(curr)) return prev * curr
                    else return prev
                }, 1)
            },

            'div': (game, context, args) => {
                if (args.length < 2) return 0
                let result = Math.floor(args[0] / args[1])
                if (!isInt(result)) return 0
                return result
            },

            'mod': (game, context, args) => {
                if (args.length < 2) return 0
                let result = args[0] % args[1]
                if (!isInt(result)) return 0
                return result
            },

            'random': (game, context, args) => {
                let min = isInt(args[0]) ? args[0] : 0
                let max = isInt(args[1]) ? args[1] : 1
                if (min > max) max = min
                return Math.floor(Math.random() * (max - min + 1)) + min
            },

            'eq': (game, context, args) => {
                if (args.length < 2) return false
                return args[0] === args[1]
            },

            'gt': (game, context, args) => {
                if (args.length < 2 || !isInt(args[0]) || !isInt(args[1])) return false
                return args[0] > args[1]
            },

            'gte': (game, context, args) => {
                if (args.length < 2 || !isInt(args[0]) || !isInt(args[1])) return false
                return args[0] >= args[1]
            },

            'lt': (game, context, args) => {
                if (args.length < 2 || !isInt(args[0]) || !isInt(args[1])) return false
                return args[0] < args[1]
            },

            'lte': (game, context, args) => {
                if (args.length < 2 || !isInt(args[0]) || !isInt(args[1])) return false
                return args[0] <= args[1]
            },

            'not': (game, context, args) => {
                if (args.length < 1) return false
                return args[0].toString() !== 'true'
            },

            'all-true': (game, context, args) => {
                let result = true
                args.forEach(arg => {
                    if (arg.toString() !== 'true') result = false
                })
                return result
            },

            'any-true': (game, context, args) => {
                let result = false
                args.forEach(arg => {
                    if (arg.toString() === 'true') result = true
                })
                return result
            },

            'none-true': (game, context, args) => {
                let result = true
                args.forEach(arg => {
                    if (arg.toString() === 'true') result = false
                })
                return result
            },

            'var': (game, context, args) => {
                if (args.length > 0 && isStr(args[0])) {
                    let varValue = game.variables[args[0]]
                    if (isStr(varValue) || isInt(varValue)) {
                        return varValue
                    } else {
                        return ''
                    }
                } else {
                    return ''
                }
            },

            'item-count': (game, context, args) => {
                if (args.length > 0 && isStr(args[0])) {
                    let itemCount = game.inventory[args[0]] || 0
                    return itemCount
                } else {
                    return 0
                }
            },

            'empty': (game, context, args) => {
                if (args.length >= 2 && isInt(args[0]) && isInt(args[1])) {
                    let x = args[0] || 0
                    let y = args[1] || 0
                    let tilesInRoom = game.currentRoom.tileList
                    let tilesAtLocation = tilesInRoom.filter(t =>
                            t.x === x && t.y === y
                        )
                    return (tilesAtLocation.length === 0)
                }
            },

            'sprite-at': (game, context, args) => {
                if (args.length >= 2 && isInt(args[0]) && isInt(args[1])) {
                    let x = args[0] || 0
                    let y = args[1] || 0
                    let tilesInRoom = game.currentRoom.tileList
                    let tilesAtLocation = tilesInRoom.filter(t =>
                            t.x === x && t.y === y
                        )
                    return tilesAtLocation
                }
            },

            'sprites-in-room': (game, context) => {
                let currentTile = context ? context.tile : null
                let tilesInRoom = game.currentRoom.tileList
                let tilesExceptMe = tilesInRoom.filter(t => t !== currentTile)
                return tilesExceptMe
            },

            'sprites-named': (game, context, args) => {
                if (args.length > 0 && isStr(args[0])) {
                    let spriteName = args[0]
                    let currentTile = context ? context.tile : null
                    let tilesInRoom = game.currentRoom.tileList
                    let tilesWithName = tilesInRoom.filter(t =>
                            t.spriteName === spriteName && t !== currentTile
                        )
                    return tilesWithName
                }
            },

            'neighbors': (game, context) => {
                if (context && context.tile) {
                    let x = context.tile.x
                    let y = context.tile.y
                    let tilesInRoom = game.currentRoom.tileList
                    let adjacentTiles = tilesInRoom.filter(t =>
                            Math.abs(t.x - x) <= 1 && Math.abs(t.y - y) <= 1 && t !== context.tile
                        )
                    return adjacentTiles
                }
            }

        }

        // define functions
        let funcs = {
            'b': (game, context, args, textSettings, addNode) => {
                addNode({ type: 'line-break' })
            },

            'p': (game, context, args, textSettings, addNode) => {
                addNode({ type: 'page-break' })
            },

            'wavy': (game, context, args, textSettings, addNode, runNodes) => {
                runNodes(args[0], context, { ...textSettings, style: 'wavy' }, addNode)
            },

            'shaky': (game, context, args, textSettings, addNode, runNodes) => {
                runNodes(args[0], context, { ...textSettings, style: 'shaky' }, addNode)
            },

            'color': (game, context, args, textSettings, addNode, runNodes) => {
                let color = args[0]
                if (!isInt(color)) color = textSettings.color
                runNodes(args[1], context, { ...textSettings, color }, addNode)
            },

            'position': (game, context, args, textSettings, addNode, runNodes) => {
                let position = args[0]
                let positionList = ['top', 'center', 'bottom', 'fullscreen']
                if (!positionList.includes(position)) position = textSettings.position
                runNodes(args[1], context, { ...textSettings, position }, addNode)
            },

            'move-avatar': (game, context, args) => {
                let roomIndex = -1, x = 0, y = 0
                if (isInt(args[0]) && isInt(args[1])) {
                    roomIndex = game.currentRoomIndex
                    x = args[0] || 0
                    y = args[1] || 0
                }
                else if (isStr(args[0]) && isInt(args[1]) && isInt(args[2])) {
                    roomIndex = game.world.roomList.findIndex(r => r.name === args[0])
                    x = args[1] || 0
                    y = args[2] || 0
                }
                if (roomIndex >= 0) {
                    x = Math.max(Math.min(x, game.world.roomWidth - 1), 0)
                    y = Math.max(Math.min(y, game.world.roomHeight - 1), 0)
                    game.moveAvatar(roomIndex, x, y)
                }
            },

            'move-sprite': (game, context, args) => {
                if (!context) return
                let roomIndex = -1, x = 0, y = 0
                if (isInt(args[0]) && isInt(args[1])) {
                    roomIndex = game.currentRoomIndex
                    x = args[0] || 0
                    y = args[1] || 0
                }
                else if (isStr(args[0]) && isInt(args[1]) && isInt(args[2])) {
                    roomIndex = game.world.roomList.findIndex(r => r.name === args[0])
                    x = args[1] || 0
                    y = args[2] || 0
                }
                if (roomIndex >= 0) {
                    x = Math.max(Math.min(x, game.world.roomWidth - 1), 0)
                    y = Math.max(Math.min(y, game.world.roomHeight - 1), 0)
                    if (game.checkTileForSprite(roomIndex, x, y)) {
                        let room = game.world.roomList[roomIndex]
                        room.tileList.push({ spriteName: context.sprite.name, x, y })
                        context.tile.removeMe = true
                    }
                }
            },

            'place-sprite': (game, context, args) => {
                let roomIndex = -1, x = 0, y = 0
                let sprite = game.world.spriteList.find(s => s.name === args[0])
                if (isStr(args[0]) && isInt(args[1]) && isInt(args[2])) {
                    roomIndex = game.currentRoomIndex
                    x = args[1] || 0
                    y = args[2] || 0
                }
                else if (isStr(args[0]) && isStr(args[1]) && isInt(args[2]) && isInt(args[3])) {
                    roomIndex = game.world.roomList.findIndex(r => r.name === args[1])
                    x = args[2] || 0
                    y = args[3] || 0
                }
                if (sprite && roomIndex >= 0) {
                    x = Math.max(Math.min(x, game.world.roomWidth - 1), 0)
                    y = Math.max(Math.min(y, game.world.roomHeight - 1), 0)
                    if (game.checkTileForSprite(roomIndex, x, y)) {
                        let room = game.world.roomList[roomIndex]
                        room.tileList.push({ spriteName: sprite.name, x, y })
                        game.updateCache()
                    }
                }
            },

            'transform-avatar': (game, context, args) => {
                let newSprite = game.world.spriteList.find(s => s.name === args[0])
                if (newSprite) {
                    game.avatar = newSprite
                    game.updateCache()
                }
            },

            'transform-sprite': (game, context, args) => {
                if (!context) return
                let newSprite = game.world.spriteList.find(s => s.name === args[0])
                if (newSprite) {
                    context.tile.spriteName = newSprite.name
                    game.updateCache()
                }
            },

            'remove-sprite': (game, context) => {
                if (!context) return
                context.tile.removeMe = true
            },

            'set-sprite-color': (game, context, args) => {
                if (!context) return
                if (isInt(args[0]) && args[0] > 0) {
                    context.sprite.colorIndex = args[0]
                    game.updateCache()
                }
                else if (isInt(args[1]) && args[1] > 0) {
                    let sprite = game.world.spriteList.find(s => s.name === args[0])
                    if (sprite) {
                        sprite.colorIndex = args[1]
                        game.updateCache()
                    }
                }
            },

            'set-sprite-wall': (game, context, args) => {
                if (!context) return
                if (args.length === 1) {
                    context.sprite.isWall = args[0] === 'true'
                }
                else if (args.length === 2) {
                    let sprite = game.world.spriteList.find(s => s.name === args[0])
                    if (sprite) sprite.isWall = args[1] === 'true'
                }
            },

            'set-sprite-item': (game, context, args) => {
                if (!context) return
                if (args.length === 1) {
                    context.sprite.isItem = args[0] === 'true'
                }
                else if (args.length === 2) {
                    let sprite = game.world.spriteList.find(s => s.name === args[0])
                    if (sprite) sprite.isItem = args[1] === 'true'
                }
            },

            'set-var': (game, context, args) => {
                if (isStr(args[0]) && (isInt(args[1]) || isStr(args[1]))) {
                    game.variables[args[0]] = args[1]
                }
            },

            'inc-var': (game, context, args) => {
                if (isStr(args[0])) {
                    let varValue = game.variables[args[0]] || 0
                    if (isInt(varValue)) {
                        let incValue = isInt(args[1]) ? args[1] : 1
                        game.variables[args[0]] = varValue + incValue
                    }
                }
            },

            'dec-var': (game, context, args) => {
                if (isStr(args[0])) {
                    let varValue = game.variables[args[0]] || 0
                    if (isInt(varValue)) {
                        let decValue = isInt(args[1]) ? args[1] : 1
                        game.variables[args[0]] = varValue - decValue
                    }
                }
            },

            'set-item-count': (game, context, args) => {
                if (isStr(args[0]) && isInt(args[1])) {
                    let itemCount = Math.max(0, args[1])
                    game.inventory[args[0]] = itemCount
                }
            },

            'inc-item-count': (game, context, args) => {
                if (isStr(args[0])) {
                    let itemCount = game.inventory[args[0]] || 0
                    let incValue = isInt(args[1]) ? args[1] : 1
                    game.inventory[args[0]] = itemCount + incValue
                }
            },

            'dec-item-count': (game, context, args) => {
                if (isStr(args[0])) {
                    let itemCount = game.inventory[args[0]] || 0
                    let incValue = isInt(args[1]) ? args[1] : 1
                    game.inventory[args[0]] = Math.max(0, itemCount - incValue)
                }
            },

            'set-palette': (game, context, args) => {
                let room, palette
                if (isStr(args[0]) && isStr(args[1])) {
                    room = game.world.roomList.find(r => r.name === args[0])
                    palette = game.world.paletteList.find(p => p.name === args[1])
                }
                else if (isStr(args[0])) {
                    room = game.currentRoom
                    palette = game.world.paletteList.find(p => p.name === args[0])
                }
                if (room && palette) {
                    room.paletteName = palette.name
                    game.updateCache()
                }
            },

            'set-music': (game, context, args) => {
                let room, music
                if (isStr(args[0]) && isStr(args[1])) {
                    room = game.world.roomList.find(r => r.name === args[0])
                    music = game.world.musicList.find(m => m.name === args[1])
                }
                else if (isStr(args[0])) {
                    room = game.currentRoom
                    music = game.world.musicList.find(m => m.name === args[0])
                }
                if (room && music) {
                    room.musicName = music.name
                    game.updateMusic()
                }
            },

            'if': (game, context, args, textSettings, addNode, runNodes) => {
                if (args.length >= 2) {
                    let result = (args[0].toString() === 'true')
                    if (result && isArr(args[1])) {
                        runNodes(args[1], context, textSettings, addNode)
                    }
                    else if (!result && isArr(args[2])) {
                        runNodes(args[2], context, textSettings, addNode)
                    }
                }
            },

            'pick': (game, context, args, textSettings, addNode, runNodes) => {
                if (args.length >= 2 && isArr(args[0])) {
                    let tiles = args[0]
                    let nodes = args[1]
                    tiles.forEach(t => {
                        let tileSprite = game.world.spriteList.find(s => s.name === t.spriteName)
                        if (tileSprite) {
                            let localContext = {
                                tile: t,
                                sprite: tileSprite,
                                roomIndex: game.currentRoomIndex
                            }
                            runNodes(nodes, localContext, textSettings, addNode)
                        }
                    })
                }
            },

            'delay': (game, context, args, textSettings, addNode, runNodes) => {
                if (isInt(args[0])) {
                    window.delayTimer = args[0]
                }
            }

        }

        let stringToTextNode = (text = '', { color, style, position }) => {
            text = text.toString().replace(/^\n+/g, '').replace(/\n+$/g, '')
            if (!text) return
            let currentPalette = game.world.paletteList[game.currentPaletteIndex]
            let colorCode = currentPalette.colorList[color] || 'white'
            return {
                type: 'text',
                color: colorCode,
                text, style, position
            }
        }

        let addActionNode = (name, action) => {
            dialogNodes.push({
                type: 'action',
                actionName: name,
                actionFunc: action
            })
        }
        
        // add custom functions and expressions
        if (game.world.modList) {
            game.world.modList.forEach(mod => {
                if (mod.type === 'expression') {
                    expressions[mod.name] = new Function('game', 'context', 'args', mod.code)
                }
                else if (mod.type === 'function') {
                    expressions[mod.name] = new Function('game', 'context', 'args', 'textSettings', 'addNode', 'runNodes', mod.code)
                }
            })
        }

        // calculate the value of an expression
        let calcExpression = (node, context) => {
            if (node.func) {
                let { func, args = [] } = node

                args = args.map(arg => calcExpression(arg, context))

                if (expressions[func]) {
                    let result = expressions[func](game, context, args)
                    if (typeof result !== 'undefined') {
                        return result
                    } else {
                        return ''
                    }
                } else {
                    return ''
                }

            } else {
                return node
            }
        }

        // run a bit of script
        let runNode = (node, context, textSettings, addNode) => {

            if (isStr(node)) {

                let textNode = stringToTextNode(node, textSettings)
                if (textNode) addNode(textNode)

            } else if (node.func) {

                let { func, args = [] } = node

                let actionFunc = () => {}
                if (funcs[func]) {
                    actionFunc = (addNodeInner) => {
                        args = args.map(arg => calcExpression(arg, context))
                        funcs[func](game, context, args, textSettings, addNodeInner, runNodes)
                    }
                } else {
                    actionFunc = (addNodeInner) => {
                        args = args.map(arg => calcExpression(arg, context))
                        let expression = calcExpression(node, context)
                        let expressionNode = stringToTextNode(expression, textSettings)
                        if (expressionNode) addNodeInner(expressionNode)
                    }
                }

                addNode({
                    type: 'action',
                    actionName: func,
                    actionFunc: actionFunc
                })

            }
        }

        // run a list of scripts
        let runNodes = (nodes = [], context, textSettings, addNode) => {
            nodes.forEach(node => {
                runNode(node, context, textSettings, addNode)
            })
        }

        // run the actual script already
        let addNode = (node) => {
            dialogNodes.push(node)
        }
        runNodes(parsedScript, context, defaultTextSettings, addNode)

        // display any dialog created from the script
        if (dialogNodes.length > 0) game.startDialog(dialogNodes)
    },

    parse: (text) => {
        let i = 0

        let parseTextNode = (closingFunc) => {
            let nodes = []
            let textSoFar = ''

            let finalizeNode = () => {
                if (textSoFar) nodes.push(textSoFar)
                textSoFar = ''
            }

            while (i < text.length) {
                let char = text.charAt(i)
                i++
                if (char === '{') {
                    finalizeNode()
                    let funcNode = parseFuncNode(text)
                    if (closingFunc && funcNode.func === closingFunc) {
                        return nodes
                    }
                    nodes.push(funcNode)
                } else {
                    textSoFar += char
                }
            }

            finalizeNode()
            return nodes
        }

        let parseFuncNode = () => {
            let funcName = ''
            while (i < text.length) {
                let char = text.charAt(i)
                if (char === ' ' || char === '\n' || char === '\t') {
                    i++
                    break
                } else if (char === '{' || char === '}') {
                    break
                } else {
                    funcName += char
                }
                i++
            }
            funcName = funcName.trim()

            let funcArgs = []
            let nextArg = ''

            let addArg = () => {
                nextArg = nextArg.trim()
                if (!nextArg) return
                if (parseInt(nextArg) === parseFloat(nextArg) && !isNaN(parseInt(nextArg))) {
                    nextArg = parseInt(nextArg)
                }
                funcArgs.push(nextArg)
                nextArg = ''
            }

            let finalizeNode = () => {
                return {
                    func: funcName,
                    args: funcArgs
                }
            }

            let insideQuote = false
            while (i < text.length) {
                let char = text.charAt(i)
                i++
                if (insideQuote) {
                    if (char === '"') {
                        insideQuote = false
                        addArg()
                    } else if (char === '\\' && text.charAt(i) === '"') {
                        i++
                        nextArg += '"'
                    } else {
                        nextArg += char
                    }
                } else {
                    if (char === '"') {
                        insideQuote = true
                    } else if (char === ' ' || char === '\n' || char === '\t') {
                        addArg()
                    } else if (char === '{') {
                        addArg()
                        funcArgs.push(parseFuncNode(text))
                    } else if (char === '}') {
                        addArg()
                        if (funcName === 'if') {
                            let ifNodes = parseTextNode('/if')
                            let elseNodes = []
                            let elseIndex = ifNodes.findIndex(n => n.func === 'else')
                            if (elseIndex > -1) {
                                elseNodes = ifNodes.slice(elseIndex + 1)
                                ifNodes = ifNodes.slice(0, elseIndex)
                            }
                            funcArgs.push(ifNodes)
                            if (elseNodes.length) funcArgs.push(elseNodes)
                        } else if (funcName === 'pick') {
                            funcArgs.push(parseTextNode('/pick'))
                        } else if (funcName === 'color') {
                            funcArgs.push(parseTextNode('/color'))
                        } else if (funcName === 'wavy') {
                            funcArgs.push(parseTextNode('/wavy'))
                        } else if (funcName === 'shaky') {
                            funcArgs.push(parseTextNode('/shaky'))
                        } else if (funcName === 'position') {
                            funcArgs.push(parseTextNode('/position'))
                        }
                        return finalizeNode()
                    } else {
                        nextArg += char
                    }
                }
            }

            return finalizeNode()
        }

        return parseTextNode()
    }
}

})()
</script>

<script>
let Game = (() => {

return class {

    constructor(world, el) {
        this.world = world

        this.wrapper = document.createElement('div')
        this.wrapper.style.position = 'relative'
        this.wrapper.style.paddingTop = '100%'
        this.wrapper.style.margin = '0 auto'
        el.appendChild(this.wrapper)

        this.canvas = document.createElement('canvas')
        this.canvas.tabIndex = "1"
        this.canvas.width = world.roomWidth * world.spriteWidth
        this.canvas.height = world.roomHeight * world.spriteHeight
        this.canvas.style.position = 'absolute'
        this.canvas.style.display = 'block'
        this.canvas.style.top = '0'
        this.canvas.style.left = '0'
        this.canvas.style.width = '100%'
        this.wrapper.appendChild(this.canvas)
        this.context = this.canvas.getContext('2d')

        this.textCanvas = document.createElement('canvas')
        this.textCanvas.width = world.roomWidth * world.spriteWidth * world.fontResolution
        this.textCanvas.height = world.roomHeight * world.spriteHeight * world.fontResolution
        this.textCanvas.style.position = 'absolute'
        this.textCanvas.style.display = 'block'
        this.textCanvas.style.top = '0'
        this.textCanvas.style.left = '0'
        this.textCanvas.style.width = '100%'
        this.wrapper.appendChild(this.textCanvas)
        this.textContext = this.textCanvas.getContext('2d')

        this.frameRate = 400
        this.dialogRate = 50
        this.nextPageDelay = 200

        this.begin = () => {
            // set up avatar
            this.avatar =
                this.world.spriteList.find(sprite => sprite.isAvatar)
                || this.world.spriteList[0]
            this.avatarX = 0
            this.avatarY = 0
            this.nextX = 0
            this.nextY = 0
            this.inventory = {}
            this.variables = {}

            // initialize animations variables
            this.lastTimestamp = 0
            this.timeToNextFrame = 0
            this.timeToNextInput = 0
            this.frameIndex = 0
            this.spriteFrameList = {}
            this.avatarDirection = 'right'

            // initialize dialog variables
            this.dialogNodes = []
            this.pageIsComplete = false
            this.nextPageTimer = 0

            // get starting room
            this.moveRooms(this.startingRoom(), true)
            this.nextRoomIndex = this.currentRoomIndex

            // run game start script
            this.runScript(this.world.worldScriptList, 'on-start')

            // initialize event handling
            this.keyActive = false
            this.keyCodes = []
            this.addEventListeners()

            // kick off update loop
            this.update(0)
        }

        this.end = () => {
            // stop any music that's playing
            MusicPlayer.stopSong()

            // clean up event listeners
            this.removeEventListeners()

            // stop animation loop
            window.cancelAnimationFrame(this.animationRequest)
        }

        this.update = (timestamp) => {
            let dt = timestamp - this.lastTimestamp
            this.lastTimestamp = timestamp

            // progress frames
            this.timeToNextFrame -= dt
            if (this.timeToNextFrame <= 0) {
                this.frameIndex++
                if (this.frameIndex >= 12) this.frameIndex = 0
                this.timeToNextFrame = this.frameRate
            }

            // update avatar
            this.timeToNextInput -= dt
            if (this.timeToNextInput <= 0) {
                this.updateAvatar()
                this.timeToNextInput = 200
            }

            // get current tiles and colors
            let tileList = this.currentRoom.tileList
            let palette = this.world.paletteList[this.currentPaletteIndex]
            let colorList = palette.colorList

            // draw background
            let canvasWidth = this.world.spriteWidth * this.world.roomWidth
            let canvasHeight = this.world.spriteHeight * this.world.roomHeight
            this.context.fillStyle = colorList[0]
            this.context.fillRect(0, 0, canvasWidth, canvasHeight)

            // draw sprites
            tileList.forEach(tile => {
                let { spriteName, x, y } = tile
                let sprite = this.world.spriteList.find(sprite => sprite.name === spriteName)
                if (sprite && !sprite.isAvatar) {
                    let xOffset = x * sprite.width
                    let yOffset = y * sprite.height
                    let frameList = this.spriteFrameList[sprite.name]
                    let frameIndex = this.frameIndex % frameList.length
                    let frameData = frameList[frameIndex]
                    this.context.drawImage(frameData, xOffset, yOffset)
                }
            })

            // draw player avatar
            this.drawAvatar()

            // draw dialog
            this.updateDialog(timestamp)

            // see you next frame!
            this.animationRequest = window.requestAnimationFrame(this.update)
        }

        this.updateAvatar = () => {
            let {
                worldWidth,
                worldHeight,
                worldWrapHorizontal,
                worldWrapVertical,
                roomWidth,
                roomHeight
            } = this.world

            let x = this.avatarX
            let y = this.avatarY
            let roomX = Math.floor(this.currentRoomIndex % worldWidth)
            let roomY = Math.floor(this.currentRoomIndex / worldWidth)
            let stopMoving = false

            // check input
            if (this.dialogNodes.length > 0) {
                // do nothing if there's dialog up
            } else if (this.keyActive) {
                let key = this.keyCodes[this.keyCodes.length - 1]
                if (key === 'ArrowLeft' || key === 'a') {
                    x--
                    this.avatarDirection = 'left'
                } else if (key === 'ArrowRight' || key === 'd') {
                    x++
                    this.avatarDirection = 'right'
                } else if (key === 'ArrowUp' || key === 'w') {
                    y--
                } else if (key === 'ArrowDown' || key === 's') {
                    y++
                }
            } else if (this.pointerIsDown || this.oneMoreMove) {
                let dx = this.pointerEndPos.x - this.pointerStartPos.x
                let dy = this.pointerEndPos.y - this.pointerStartPos.y

                if (dx * dx + dy * dy > 20 * 20) {
                    let angle = Math.atan2(dy, dx) * 180 / Math.PI + 180
                    if (angle > 45 && angle <= 135) {
                        y--
                    } else if (angle > 135 && angle <= 225) {
                        x++
                        this.avatarDirection = 'right'
                    } else if (angle > 225 && angle <= 315) {
                        y++
                    } else {
                        x--
                        this.avatarDirection = 'left'
                    }
                    this.movesSinceLastTouch++
                    this.oneMoreMove = false
                }
            }

            // check if avatar is going outside of room bounds
            if (x < 0) {
                x = roomWidth - 1
                roomX--
            }
            if (x >= roomWidth) {
                x = 0
                roomX++
            }
            if (y < 0) {
                y = roomHeight - 1
                roomY--
            }
            if (y >= roomHeight) {
                y = 0
                roomY++
            }

            // check if avatar is going outside of world bounds
            if (roomX < 0) {
                if (worldWrapHorizontal) roomX = worldWidth - 1
                else stopMoving = true
            }
            if (roomX >= worldWidth) {
                if (worldWrapHorizontal) roomX = 0
                else stopMoving = true
            }
            if (roomY < 0) {
                if (worldWrapVertical) roomY = worldHeight - 1
                else stopMoving = true
            }
            if (roomY >= worldHeight) {
                if (worldWrapVertical) roomY = 0
                else stopMoving = true
            }
            if (stopMoving) return

            // move avatar
            let roomIndex = (roomY * worldWidth) + roomX
            this.moveAvatar(roomIndex, x, y)
        }

        this.moveAvatar = (roomIndex, x, y) => {
            let stopMoving = false

            // reset next positions
            this.nextRoomIndex = roomIndex
            this.nextX = x
            this.nextY = y

            // check for tile interactions
            let tileIsClear = this.checkTileForAvatar(this.nextRoomIndex, this.nextX, this.nextY)
            if (!tileIsClear) stopMoving = true

            // remove any tiles marked for death
            this.world.roomList.forEach(r => {
                r.tileList = r.tileList.filter(tile => !tile.removeMe)
            })

            // finalize avatar movement
            if (!stopMoving) {
                this.avatarX = this.nextX
                this.avatarY = this.nextY
                this.moveRooms(this.nextRoomIndex)
            }
        }

        this.checkTileForAvatar = (roomIndex, x, y) => {
            let room = this.world.roomList[roomIndex]
            let tileIsClear = true

            // look at each tile in the room
            room.tileList.forEach(tile => {
                // ignore tiles that player is not going to be standing on
                if (tile.x !== x || tile.y !== y) return

                // get sprite data for the current tile
                let sprite = this.world.spriteList.find(s => s.name === tile.spriteName)

                // ignore sprite if it's the avatar or if it doesn't exist
                if (!sprite || sprite.isAvatar) return

                // it's a wall - block the way!
                if (sprite.isWall) {
                    tileIsClear = false
                }

                // it's an item - pick it up!
                if (sprite.isItem) {
                    this.addToInventory(sprite.name, 1)
                    tile.removeMe = true
                }

                // run the sprite's script (if player's not already on this tile)
                if (this.avatarX !== x || this.avatarY !== y) {
                    this.runScript(sprite.scriptList, 'on-push', { sprite, tile, roomIndex })
                }
            })

            // return whether tile is blocking player movement
            return tileIsClear
        }

        this.checkTileForSprite = (roomIndex, x, y) => {
            let room = this.world.roomList[roomIndex]
            let tileIsClear = true

            // look at each tile in the room
            room.tileList.forEach(tile => {
                // ignore tiles that player is not going to be standing on
                if (tile.x !== x || tile.y !== y) return

                // get sprite data for the current tile
                let sprite = this.world.spriteList.find(s => s.name === tile.spriteName)

                // it's a wall - block the way!
                if (sprite.isWall) tileIsClear = false
            })

            // return whether tile is blocking player movement
            return tileIsClear
        }

        this.startDialog = (dialogNodes) => {
            this.dialogNodes = dialogNodes
            this.pageStartTimestamp = null
            this.pageIsComplete = false
            window.textPosition = null
        }

        this.progressDialog = () => {
            if (this.pageIsComplete && this.nextPageTimer >= this.nextPageDelay) {
                this.pageStartTimestamp = null
                this.pageIsComplete = false
                this.nextPageTimer = 0
                this.dialogNodes = this.dialogNodes.slice(this.nextPageNodeIndex)

                if (this.dialogNodes.length === 0) {
                    // clear text canvas when dialog is complete
                    this.textContext.clearRect(0, 0, this.textCanvas.width, this.textCanvas.height)
                }
            } else {
                this.pageIsComplete = true
            }
        }

        this.updateDialog = (timestamp) => {
            if (this.dialogNodes.length === 0) return

            let canvas = this.textCanvas
            let context = this.textContext
            let { fontData, fontDirection } = this.world

            context.clearRect(0, 0, canvas.width, canvas.height)

            // calculate number of characters to draw
            if (!this.pageStartTimestamp) this.pageStartTimestamp = timestamp
            let dt = timestamp - this.pageStartTimestamp
            let maxChars = this.pageIsComplete ? -1 : Math.floor(dt / this.dialogRate)

            // draw background
            if (!window.textPosition) window.textPosition = 'none'
            let { bgX, bgY, bgWidth, bgHeight } = Text.drawBackground(context, fontData, window.textPosition)

            // draw continue indicator
            if (this.pageIsComplete) {
                if (window.textPosition === 'none') {
                    // skip end-of-page delay if no text
                    this.nextPageTimer = this.nextPageDelay
                } else {
                    // otherwise show next-page indicator and progress the delay timer
                    this.nextPageTimer += Math.floor(dt / this.dialogRate)
                    if (this.nextPageTimer >= this.nextPageDelay) {
                        Text.drawContinueIndicator(context, fontData, bgX, bgY, bgWidth, bgHeight)
                    }
                }
            }

            // draw text
            let nextPageNodeIndex = Text.drawNode({
                nodes: this.dialogNodes,
                canvas,
                context,
                fontData,
                fontDirection,
                timestamp,
                maxChars,
                bgX, bgY
            })

            if (nextPageNodeIndex >= 0) {
                let textNodeCount = this.dialogNodes.filter((node, i) =>
                        (node.type === 'text' && i < nextPageNodeIndex)
                    ).length

                this.pageIsComplete = true
                this.nextPageNodeIndex = nextPageNodeIndex

                if (textNodeCount === 0) this.progressDialog()
            }
        }

        this.addToInventory = (item, quantity) => {
            // add item to the player's inventory
            if (!this.inventory[item]) this.inventory[item] = 0
            this.inventory[item] += quantity
            if (this.inventory[item] < 0) this.inventory[item] = 0
        }

        this.startingRoom = () => {
            // find the room that the player starts in
            let roomIndex = 0
            this.world.roomList.forEach((room, i) => {
                room.tileList.forEach(tile => {
                    if (tile.spriteName === this.avatar.name) {
                        roomIndex = i
                        this.avatarX = tile.x
                        this.avatarY = tile.y
                    }
                })
            })
            return roomIndex
        }

        this.moveRooms = (roomIndex, startOfGame) => {
            // ignore if player is already in this room
            if (this.currentRoomIndex === roomIndex) return

            // run exit script for old room
            if (!startOfGame && this.currentRoom) {
                this.runScript(this.currentRoom.scriptList, 'on-exit')
            }

            // update room references
            this.currentRoomIndex = roomIndex
            this.currentRoom = this.world.roomList[this.currentRoomIndex]

            // update color palette
            this.currentPaletteIndex = this.world.paletteList.findIndex(p => p.name === this.currentRoom.paletteName)

            // play new music
            this.updateMusic()

            // cache new sprites
            this.updateCache()

            // run enter script for new room
            if (!startOfGame) {
                this.runScript(this.currentRoom.scriptList, 'on-enter')
            }
        }

        this.updateMusic = () => {
            // find music for current room
            let musicIndex = this.world.musicList.findIndex(m => m.name === this.currentRoom.musicName)

            // stop previous music and play new music, if changed
            if (musicIndex !== this.currentMusicIndex) {
                this.currentMusicIndex = musicIndex
                MusicPlayer.stopSong()
                let music = this.world.musicList[musicIndex]
                if (music) MusicPlayer.playSong(music)
            }
        }

        this.runScript = (scriptList, scriptName, context) => {
            // ignore non-existent scripts
            if (!scriptList || !scriptList[scriptName]) return

            // get script
            let script = scriptList[scriptName]

            // run script
            Script.run(script, this, context)
        }

        this.nextFrames = () => {
            Object.keys(this.spriteFrameIndexList).forEach(key => {
                let frameIndex = this.spriteFrameIndexList[key]

                this.frameIndex = frameIndex || 0
                if (this.frameIndex >= this.frameCanvasList.length) {
                    this.frameIndex = 0
                }
            })
        }

        this.drawFrame = (frame, width, context) => {
            frame.forEach((pixel, i) => {
                let x = Math.floor(i % width)
                let y = Math.floor(i / width)
                if (pixel) context.fillRect(x, y, 1, 1)
            })
        }

        this.getFrameData = (frame, color, flipped, bgColor) => {
            let { spriteWidth, spriteHeight } = this.world

            let frameCanvas = document.createElement('canvas')
            frameCanvas.width = spriteWidth
            frameCanvas.height = spriteHeight

            let context = frameCanvas.getContext('2d')
            if (flipped) {
                context.translate(spriteWidth, 0)
                context.scale(-1, 1)
            }

            if (bgColor) {
                context.fillStyle = bgColor
                context.fillRect(0, 0, spriteWidth, spriteHeight)
            }

            context.fillStyle = color
            this.drawFrame(frame, spriteWidth, context)

            let frameData = frameCanvas
            return frameData
        }

        this.cacheSprite = (sprite, colorList, flipped) => {
            let name = sprite.name + (flipped ? '__flipped' : '')
            let colorIndex = sprite.colorIndex
            while (colorIndex > 0 && !colorList[colorIndex]) colorIndex--
            let color = colorList[colorIndex]
            let bgColor = sprite.isTransparent ? null : colorList[0]

            if (sprite && !this.spriteFrameList[name]) {
                this.spriteFrameList[name] = sprite.frameList.map(frame => {
                    return this.getFrameData(frame, color, flipped, bgColor)
                })
            }
        }

        this.updateCache = () => {
            let tileList = this.currentRoom.tileList
            this.currentPaletteIndex = this.world.paletteList.findIndex(p => p.name === this.currentRoom.paletteName)
            let palette = this.world.paletteList[this.currentPaletteIndex]
            let colorList = palette.colorList

            this.spriteFrameList = {}

            tileList.forEach(tile => {
                let { spriteName } = tile
                let sprite = this.world.spriteList.find(s => s.name === spriteName)
                this.cacheSprite(sprite, colorList)
            })

            this.cacheSprite(this.avatar, colorList)
            this.cacheSprite(this.avatar, colorList, true)
        }

        this.drawAvatar = () => {
            let { spriteWidth, spriteHeight } = this.world
            let name = this.avatar.name
            if (this.avatarDirection === 'left') name += '__flipped'

            let frameList = this.spriteFrameList[name]
            let frameIndex = this.frameIndex % frameList.length
            let frameData = frameList[frameIndex]
            this.context.drawImage(frameData, this.avatarX * spriteWidth, this.avatarY * spriteHeight)
        }

        this.addEventListeners = () => {
            document.addEventListener('keydown', this.keyDown)
            document.addEventListener('keyup', this.keyUp)

            this.wrapper.addEventListener('mousedown', this.pointerStart)
            document.addEventListener('mouseup', this.pointerEnd)
            document.addEventListener('mousemove', this.pointerMove)

            this.wrapper.addEventListener('touchstart', this.pointerStart, { passive: false })
            document.addEventListener('touchend', this.pointerEnd, { passive: false })
            document.addEventListener('touchcancel', this.pointerEnd, { passive: false })
            document.addEventListener('touchmove', this.pointerMove, { passive: false })

            window.addEventListener('resize', this.resize)
            this.resize()
        }

        this.removeEventListeners = () => {
            document.removeEventListener('keydown', this.keyDown)
            document.removeEventListener('keyup', this.keyUp)

            this.wrapper.removeEventListener('mousedown', this.pointerDown)
            document.removeEventListener('mouseup', this.pointerEnd)
            document.removeEventListener('mousemove', this.pointerMove)

            this.wrapper.removeEventListener('touchstart', this.pointerDown)
            document.removeEventListener('touchend', this.pointerEnd)
            document.removeEventListener('touchcancel', this.pointerEnd)
            document.removeEventListener('touchmove', this.pointerMove)

            window.removeEventListener('resize', this.resize)
        }

        this.keyDown = (e) => {
            if (e.key.startsWith('Arrow') || ['w', 'a', 's', 'd'].includes(e.key)) e.preventDefault() // prevent arrow keys from scrolling page
            if (e.repeat) return // ignore key repeats
            if (e.key === 'm') {
                window.muteMusic = !window.muteMusic
            }
            else if (this.dialogNodes.length > 0) {
                if (e.key.startsWith('Arrow') || ['w', 'a', 's', 'd'].includes(e.key)) {
                    this.progressDialog()
                }
            } else {
                this.keyActive = true
                this.keyCodes.push(event.key)
                this.timeToNextInput = 0
            }
        }

        this.keyUp = (e) => {
            this.keyCodes = this.keyCodes.filter(keyCode => keyCode !== e.key)
            if (this.keyCodes.length === 0) this.keyActive = false
        }

        this.pointerStart = (e) => {
            e.preventDefault()
            this.canvas.focus()
            let pointer = e.touches ? e.touches[0] : e
            this.pointerIsDown = true
            this.movesSinceLastTouch = 0
            this.pointerStartPos = {
                x: pointer.clientX,
                y: pointer.clientY
            }
            this.pointerEndPos = {
                x: pointer.clientX,
                y: pointer.clientY
            }
            this.timeToNextInput = 0
        }

        this.pointerMove = (e) => {
            if (this.pointerIsDown) {
                e.preventDefault()
                let pointer = e.touches ? e.touches[0] : e
                this.pointerEndPos = {
                    x: pointer.clientX,
                    y: pointer.clientY
                }
            }
        }

        this.pointerEnd = (e) => {
            if (this.pointerIsDown) {
                e.preventDefault()
                this.pointerIsDown = false
                if (this.dialogNodes.length > 0) {
                    this.progressDialog()
                } else {
                    if (this.movesSinceLastTouch === 0) {
                        this.oneMoreMove = true
                        this.timeToNextInput = 0
                    }
                }
            }
        }

        this.resize = () => {
            this.canvas.focus()
            let width = this.canvas.width
            let height = this.canvas.height
            let widthRatio = width > height ? 1 : width / height
            let heightRatio = width > height ? height / width : 1
            this.wrapper.style.width = widthRatio * 100 + '%',
            this.wrapper.style.paddingTop = heightRatio * 100 + '%'
        }
    }

}

})()
</script>

<script>
window.onload = () => {
    let wrapper = document.getElementById('game-wrapper')
    this.game = new Game(window.GAME_DATA, wrapper)
    this.game.begin()
}
</script>

</head>

<body>
<div id='game-wrapper'></div>
</body>

</html>
